---
layout: post
title: "Особенности работы ARP протокола в Junos"
tags: junos arp
author: "orlik"
---

Особенности обработки ARP запросов в Junos

## Обработка исходящих ARP запросов 

Когда на маршрутизатор приходит пакет, у которого destination адрес принадлежит direct сети на ethernet интерфейсе, PFE выполняет поиск в таблице маршрутизации для адреса назначения, результатом которого возможны три варианта:

Будет найдена /32 запись с nh type - unicast, это означает, что для данного маршрута уже есть arp запись и пакет можно отправить далее  

```
> request pfe execute command "sh route ip prefix 10.0.150.205 detail" target afeb0
SENT: Ukern command: sh route ip prefix 10.0.150.205 detail

IPv4 Route Table 0, default.0, 0x80000:
Destination                       NH IP Addr      Type     NH ID Interface
--------------------------------- --------------- -------- ----- ---------
10.0.150.205                     10.0.150.205    Unicast   986 RT-ifl 444 ge-0/0/1.172 ifl 444
```

Будет найдена запись с nh type - resolve, подобная запись является конечной в поиске только при отсутствии /32 записей для данного адреса. Когда трафик попадает под Resolve маршрут, лукап чип отрпавляет оповещение на PFE CPU о необходимости выполнить резолв для данного адреса. При этом создается локальная запись о том, что FPC пытается резолвить данный маршрут. После этого отправляется запрос на RE о необходимости выполнения резолва. 
```
> request pfe execute command "sh route ip prefix 10.0.150.200/29" target afeb0
SENT: Ukern command: sh route ip prefix 10.0.150.200/29


IPv4 Route Table 0, default.0, 0x80000:
Destination                       NH IP Addr      Type     NH ID Interface
--------------------------------- --------------- -------- ----- ---------
10.0.150.200/29                                   Resolve   968 RT-ifl 444 ge-0/0/1.172 ifl 444
```
Если по истечении этого таймера, от RE не будет получено ответа (например потому-что данный хост недоступен и не может от отрезолвлен) то интерфейс с которого пришел запрос на резолв на 10 секунд помечается как throttled и все дельнейшие запросы о необходимости резолва от данного интерфейса и приходящие на FPC CPU игнорируются. При этом вы можете видеть в сислоге FPC сообщения вида
```
[Jan  1 01:01:01.001 LOG: Info] NH_RESOLUTION_REQ_THROTTLED: Next-hop resolution requests from interface 350 throttled
```

Третий вариант записи в таблице имеет nh type - hold. Данный тип записи создает RE после того, как получит запрос на резолв от FPC CPU, после чего RE отправляет arp who-has запрос с интерфейса (в нашем случае это ge-0/0/1.172). Данный тип записи необходим чтобы избежать ситуации когда RE одновременно отправит несколько запросов на резолв для одного и тогоже адреса (например пришедшие с разных FPC).

```
> request pfe execute command "sh route ip prefix 10.0.150.204" target afeb0
SENT: Ukern command: sh route ip prefix 10..150.204


IPv4 Route Table 0, default.0, 0x80000:
Destination                       NH IP Addr      Type     NH ID Interface
--------------------------------- --------------- -------- ----- ---------
10.0.150.204                                      Hold  9705 RT-ifl 444 ge-0/0/1.172 ifl 444
```

Если RE получит ответ на свой arp запрос, то данная запись будет сконвертирована из hold в unicast и в arp таблице появится соответствующая запись

```
> show arp no-resolve interface ge-0/0/1.172 expiration-time
MAC Address       Address         Interface                TTE    Flags
00:0c:29:0a:37:7f 10.0.150.205   ge-0/0/1.172             1441    none
Total entries: 1
```

## Обработка входящих ARP запросов

Все входящие arp пакеты (не только запросы с броадкастным адресом назначения но в принципе все пакеты у которых EtherType = 0x0806,в том числе ответы на запросы отправленные нашим маршрутизатором и даже пакеты с dst mac других клиентов, которые попали к нам ошибочно, например из-за петли или hash-collision на L2 оборудовании подключенном на данном интерфейсе ) попадают под действие `__default_arp_policer__`. Данный полисер применен глобально на каждом PFE и обрабатывает arp запросы для всех интерфейсов одного PFE. 
Пропускная способность `__default_arp_policer__` - 150000 bps и burst 15000 bytes. При размере arp запроса в 42 байта, мы получаем что данный полисер может пропустить ~446 запросов/с. В случае если на один PFE поступает больше 446 пакетов в секунду все лишние запросы будут отброшены полисером. В такой ситуации существует вероятность, что часть пакетов не дойдет до RE и как следствие arp записи на интерфейсах этого PFE не обновятся и будут удалены. Это черевато кратковременными пропаданиями связи у клиентов и как вариант падением некоторых протоколов маршрутизации (bgp/ldp/rsvp).

Все пакеты далее попадают на PFE CPU откуда пересылаются на RE. 

Между PFE и RE пакеты попадают в отдельную очередь `L2 Packets`
```
>request pfe execute command "show ttp statistics" target afeb0
...
TTP Receive Statistics:
                   Control        High      Medium         Low     Discard
                ----------  ----------  ----------  ----------  ----------
 L2 Packets              0         129          80           0           0
 L3 Packets              0         754        1375           0           0
 Drops                   0           0           0           0           0
 Queue Drops             0           0           0           0           0
 Unknown                 0           0           0           0           0
 Coalesce                0           0           0           0           0
 Coalesce Fail           0           0           0           0           0
...
```

После чего все arp пакеты , от всех PFE попадают в kernel очередь, где и обрабатываются. 

## __default_arp_policer__

Мониторить данный полисер можно из cli
```
> show policer __default_arp_policer__
Policers:
Name                                                Bytes              Packets
__default_arp_policer__                       64833769988           1439659193
```

или по snmp (лучше по pps)
```
OID: .1.3.6.1.4.1.2636.3.5.1.1.4.23.95.95.100.101.102.97.117.108.116.95.97.114.112.95.112.111.108.105.99.101.114.95.95.23.95.95.100.101.102.97.117.108.116.95.97.114.112.95.112.111.108.105.99.101.114.95.95
```
Или использовать телеметрию. 

### Способы защиты от arp flood

`__default_arp_policer__` - нужен чтобы защитить RE от флуда, но если не мониторить количество отброшенных им пакетов, то при флуде от клиентов ваш маршрутизатор будет чувствовать себя хорошо, в отличии от ваших клиентов которые будут испытывать серьезные проблемы со связью. Поэтому есть несколько вариантов, как защититься от подобных ситуаций. 

* **индивидуальные arp полисеры** На каждый логический интерфейс примененяется свой, индивидуальный arp полисер. В таком случае все arp пакеты на этом интерфейсе будут попадать под действие этого полисера и не будут попадать под `__default_arp_policer__`. В случае флуда на данном интерфейсе, все лишние пакеты будут отброщены данным полисерором не оказывая никакого влияния на другие интерфейсы

```
> show configuration interfaces ge-0/0/1.172
family inet {
    policer {
        arp arp8k;
    }
    address 10.0.150.201/29;
}
```

* **Отключение __default_arp_policer__** - Самые смелые могут отключить `__default_arp_policer__` на интерфейсе(отключать нужно на каждом логическом интерфейсе). Отключается командой `set interfaces ge-0/0/1.172 family inet policer disable-arp-policer`, главное убедиться, что полисер отключился. Увидеть это можно по отсутствию строки `Policer: Input: __default_arp_policer__` в выводе команды `show interface detail ge-0/0/1.172`
При этом нужно понимать, что в этом случае на PFE нет никакой защиты от arp флуда и большое кол-во запросов может повлиять на стабильность системы. 

* **ddos-protection** - В Junos присутствует механизм ddos-protection для защиты RE от всевозможных атак, в том чесле и от флуда arp пакетами. Особенностью реализации данного вида зациты, является очередность с которой обрабатывается arp трафик. Сначала трафик попадает под действие arp полисера (индивидуального или __default_arp_policer__) и только после этого трафик обрабатывается системой анализа ddos-protection. Таким образом с настройками по умолчанию (bandwidth 20000 pps) ddos-protection для протокола arp никогда не сработает. Необходимо снижать пороговые значения для того чтобы система детектировала атаки. 

Дополнительно хочется расмотреть такой случай:
* отсутствие каких-либо полисеров для arp запросов на интерфесах
* настроенный ddos-protection для протокола arp чтобы он срабатывал раньше чем пакеты начнут дропаться `__default_arp_policer__` (bw = 400pps burst=100pps).
* включен flow-detection, хотя данное условие не обязательное
* от всех клиентов в среднем поступает 100pps arp пакетов
* клиент от которого поступает большое количество arp запросов (пусть будет 1000pps)

 В данном случае сначала все arp запросы попадут под действие `__default_arp_policer__`, после которого дальше пройдет только ~440pps. Эти 440 pps вызовут срабатывание ddos-protection и включение flow-detection, после чего вредоносные flow будут заблокированы и не будут поступать на control-plane оборудования. Но блокироваться данные вредоносные flow будут после `__default_arp_policer__`, таким образом из 1100pps более 600pps будут по прежнему отбрасываться на `__default_arp_policer__`, что будет негативно сказываться на работе других клиентов. Поэтому при срабатывании ddos-protection для восстановления нормальной работы клиентов необходимо выставлять индивидуальные arp полисеры на "проблемных клиентов"
 Это можно автоматизировать через конфигурирование event-options, например так:
```
policy arpddos {
    events ddos_scfd_flow_found;
    attributes-match {
        ddos_scfd_flow_found.protocol-name matches ARP;
    }
    then {
        change-configuration {
            commands {
                "set interfaces {$$.source-name} family inet policer arp arp8k";
            }
        }
    }
}
```
Или можно выполнять скрипт , который будет применять arp полисеры различной емкости в зависимости от сконфигуренных на интерфейсе маски сети.


